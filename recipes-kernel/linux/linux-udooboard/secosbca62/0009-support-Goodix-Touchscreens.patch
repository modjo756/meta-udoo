Index: git/arch/arm/boot/dts/imx6qdl-seco_A62.dtsi
===================================================================
--- git.orig/arch/arm/boot/dts/imx6qdl-seco_A62.dtsi
+++ git/arch/arm/boot/dts/imx6qdl-seco_A62.dtsi
@@ -333,17 +333,24 @@
 			fsl,pins = <
 				MX6QDL_PAD_GPIO_5__I2C3_SCL             0x4001b8b1
 				MX6QDL_PAD_GPIO_6__I2C3_SDA             0x4001b8b1
-
-				MX6QDL_PAD_SD2_DAT2__GPIO1_IO13   	0x80000000       /*touch interrupt*/ 
-				MX6QDL_PAD_SD2_DAT0__GPIO1_IO15   	0x80000000       /* touch reset */ 
 			>;
 		};
 /*  __________________________________________________________________________
+* |________________________________ TOUCH ___________________________________|
+*/
+		pinctrl_gt928: gt928grp {
+			fsl,pins = <
+				MX6QDL_PAD_SD2_DAT2__GPIO1_IO13              0x80000000		// Touch Interrupt
+				MX6QDL_PAD_SD2_DAT0__GPIO1_IO15              0x80000000		// Touch Reset
+                        >;
+ 		};
+/*  __________________________________________________________________________
  * |_________________________________ SPI ____________________________________|
  */
 		pinctrl_ecspi1: ecspi1grp {
 			fsl,pins = <
-				MX6QDL_PAD_EIM_D17__ECSPI1_MISO         0x100b1   
+				MX6QDL_PAD_EIM_D17__ECSPI1_MISO         0x100b1
+				
 				MX6QDL_PAD_EIM_D18__ECSPI1_MOSI         0x100b1  
 				MX6QDL_PAD_EIM_D16__ECSPI1_SCLK         0x100b1  
 				/*  CS SPI 1  */
@@ -650,13 +657,26 @@
 		mclk_source = <0>;
 	};
 
-	touchscreen@55 {
- 		compatible = "sitronix,st1232";
- 		reg = <0x55>;
- 		interrupt-parent = <&gpio1>;
- 		interrupts = <13 IRQ_TYPE_LEVEL_LOW>;
- 		gpios = <&gpio1 15 GPIO_ACTIVE_LOW>;
- 	};
+	//touchscreen@55 {
+ 		//compatible = "sitronix,st1232";
+ 		//reg = <0x55>;
+                //pinctrl-names    = "default";
+		//pinctrl-0        = <&pinctrl_st1232>;
+ 		//interrupt-parent = <&gpio1>;
+ 		//interrupts = <13 IRQ_TYPE_LEVEL_LOW>;
+ 		//gpios = <&gpio1 15 GPIO_ACTIVE_LOW>;
+ 	//};
+        gt928@5d {
+		compatible       = "goodix,gt928";
+		reg              = <0x5d>;
+                touchscreen-inverted-y;
+		pinctrl-names    = "default";
+		pinctrl-0        = <&pinctrl_gt928>;
+		interrupt-parent = <&gpio1>;
+		interrupts       = <13 IRQ_TYPE_LEVEL_LOW>;
+		irq-gpio         = <&gpio1 13 GPIO_ACTIVE_LOW>;
+		reset-gpio       = <&gpio1 15 GPIO_ACTIVE_LOW>;
+	};
 };
 /*  __________________________________________________________________________
  * |__________________________________________________________________________|
Index: git/drivers/base/devres.c
===================================================================
--- git.orig/drivers/base/devres.c
+++ git/drivers/base/devres.c
@@ -297,10 +297,10 @@ void * devres_get(struct device *dev, vo
 	if (!dr) {
 		add_dr(dev, &new_dr->node);
 		dr = new_dr;
-		new_res = NULL;
+		new_dr = NULL;
 	}
 	spin_unlock_irqrestore(&dev->devres_lock, flags);
-	devres_free(new_res);
+	devres_free(new_dr);
 
 	return dr->data;
 }
@@ -791,6 +791,61 @@ void * devm_kmalloc(struct device *dev,
 EXPORT_SYMBOL_GPL(devm_kmalloc);
 
 /**
+ * devm_kvasprintf - Allocate resource managed space
+ *                      for the formatted string.
+ * @dev: Device to allocate memory for
+ * @gfp: the GFP mask used in the devm_kmalloc() call when
+ *       allocating memory
+ * @fmt: the formatted string to duplicate
+ * @ap: the list of tokens to be placed in the formatted string
+ * RETURNS:
+ * Pointer to allocated string on success, NULL on failure.
+ */
+char *devm_kvasprintf(struct device *dev, gfp_t gfp, const char *fmt,
+                      va_list ap)
+{
+        unsigned int len;
+        char *p;
+        va_list aq;
+
+        va_copy(aq, ap);
+        len = vsnprintf(NULL, 0, fmt, aq);
+        va_end(aq);
+
+        p = devm_kmalloc(dev, len+1, gfp);
+        if (!p)
+                return NULL;
+
+        vsnprintf(p, len+1, fmt, ap);
+
+        return p;
+}
+EXPORT_SYMBOL(devm_kvasprintf);
+
+/**
+ * devm_kasprintf - Allocate resource managed space
+ *              and copy an existing formatted string into that
+ * @dev: Device to allocate memory for
+ * @gfp: the GFP mask used in the devm_kmalloc() call when
+ *       allocating memory
+ * @fmt: the string to duplicate
+ * RETURNS:
+ * Pointer to allocated string on success, NULL on failure.
+ */
+char *devm_kasprintf(struct device *dev, gfp_t gfp, const char *fmt, ...)
+{
+        va_list ap;
+        char *p;
+
+        va_start(ap, fmt);
+        p = devm_kvasprintf(dev, gfp, fmt, ap);
+        va_end(ap);
+
+        return p;
+}
+EXPORT_SYMBOL_GPL(devm_kasprintf);
+
+/**
  * devm_kfree - Resource-managed kfree
  * @dev: Device this memory belongs to
  * @p: Memory to free
Index: git/drivers/input/touchscreen/Kconfig
===================================================================
--- git.orig/drivers/input/touchscreen/Kconfig
+++ git/drivers/input/touchscreen/Kconfig
@@ -296,7 +296,8 @@ config TOUCHSCREEN_GOODIX
 	help
 	  Say Y here if you have the Goodix touchscreen (such as one
 	  installed in Onda v975w tablets) connected to your
-	  system.
+	  system.It also supports 5-finger chip models, which can be
+          found on ARM tablets, like Wexler TAB7200 and MSI Primo73.
 
 	  If unsure, say N.
 
Index: git/drivers/input/touchscreen/Makefile
===================================================================
--- git.orig/drivers/input/touchscreen/Makefile
+++ git/drivers/input/touchscreen/Makefile
@@ -34,6 +34,7 @@ obj-$(CONFIG_TOUCHSCREEN_ELO)		+= elo.o
 obj-$(CONFIG_TOUCHSCREEN_ELAN)      += elan_ts.o
 obj-$(CONFIG_TOUCHSCREEN_EGALAX)	+= egalax_ts.o
 obj-$(CONFIG_TOUCHSCREEN_FUJITSU)	+= fujitsu_ts.o
+obj-$(CONFIG_TOUCHSCREEN_GOODIX) 	+= goodix.o
 obj-$(CONFIG_TOUCHSCREEN_ILI210X)	+= ili210x.o
 obj-$(CONFIG_TOUCHSCREEN_INEXIO)	+= inexio.o
 obj-$(CONFIG_TOUCHSCREEN_INTEL_MID)	+= intel-mid-touch.o
Index: git/drivers/input/touchscreen/goodix.c
===================================================================
--- git.orig/drivers/input/touchscreen/goodix.c
+++ git/drivers/input/touchscreen/goodix.c
@@ -2,6 +2,7 @@
  *  Driver for Goodix Touchscreens
  *
  *  Copyright (c) 2014 Red Hat Inc.
+ *  Copyright (c) 2015 K. Merker <merker@debian.org>
  *
  *  This code is based on gt9xx.c authored by andrew@goodix.com:
  *
@@ -15,7 +16,9 @@
  */
 
 #include <linux/kernel.h>
-#include <linux/gpio.h>
+#include <linux/dmi.h>
+#include <linux/firmware.h>
+#include <linux/gpio/consumer.h>
 #include <linux/i2c.h>
 #include <linux/input.h>
 #include <linux/input/mt.h>
@@ -24,41 +27,85 @@
 #include <linux/irq.h>
 #include <linux/interrupt.h>
 #include <linux/slab.h>
+#include <linux/acpi.h>
+#include <linux/of.h>
 #include <linux/of_gpio.h>
 #include <asm/unaligned.h>
 
 struct goodix_ts_data {
-	struct i2c_client *client;
-	struct input_dev *input_dev;
-	int abs_x_max;
-	int abs_y_max;
-	unsigned int max_touch_num;
-	unsigned int int_trigger_type;
-	bool invert;
-	bool rotate;
+        struct i2c_client *client;
+        struct input_dev *input_dev;
+        int abs_x_max;
+        int abs_y_max;
+        bool swapped_x_y;
+        bool inverted_x;
+        bool inverted_y;
+        unsigned int max_touch_num;
+        unsigned int int_trigger_type;
+        int cfg_len;
+        int gpio_int;
+        int gpio_rst;
+        u16 id;
+        u16 version;
+        const char *cfg_name;
+        struct completion firmware_loading_complete;
+        unsigned long irq_flags;
 };
 
-#define GOODIX_MAX_HEIGHT		4096
-#define GOODIX_MAX_WIDTH		4096
-#define GOODIX_INT_TRIGGER		1
-#define GOODIX_CONTACT_SIZE		8
-#define GOODIX_MAX_CONTACTS		10
+#define GOODIX_GPIO_INT_NAME            "irq-gpio"
+#define GOODIX_GPIO_RST_NAME            "reset-gpio"
 
-#define GOODIX_CONFIG_MAX_LENGTH	240
+#define GOODIX_MAX_HEIGHT               4096
+#define GOODIX_MAX_WIDTH                4096
+#define GOODIX_INT_TRIGGER              1
+#define GOODIX_CONTACT_SIZE             8
+#define GOODIX_MAX_CONTACTS             10
+
+#define GOODIX_CONFIG_MAX_LENGTH        240
+#define GOODIX_CONFIG_911_LENGTH        186
+#define GOODIX_CONFIG_967_LENGTH        228
 
 /* Register defines */
-#define GOODIX_READ_COOR_ADDR		0x814E
-#define GOODIX_REG_CONFIG_DATA		0x8047
-#define GOODIX_REG_VERSION		0x8140
+#define GOODIX_REG_COMMAND              0x8040
+#define GOODIX_CMD_SCREEN_OFF           0x05
 
-#define RESOLUTION_LOC		1
-#define TRIGGER_LOC		6
+#define GOODIX_READ_COOR_ADDR           0x814E
+#define GOODIX_REG_CONFIG_DATA          0x8047
+#define GOODIX_REG_ID                   0x8140
+
+#define RESOLUTION_LOC          1
+#define MAX_CONTACTS_LOC        5
+#define TRIGGER_LOC             6
 
 static const unsigned long goodix_irq_flags[] = {
-	IRQ_TYPE_EDGE_RISING,
-	IRQ_TYPE_EDGE_FALLING,
-	IRQ_TYPE_LEVEL_LOW,
-	IRQ_TYPE_LEVEL_HIGH,
+        IRQ_TYPE_EDGE_RISING,
+        IRQ_TYPE_EDGE_FALLING,
+        IRQ_TYPE_LEVEL_LOW,
+        IRQ_TYPE_LEVEL_HIGH,
+};
+
+/*
+ * Those tablets have their coordinates origin at the bottom right
+ * of the tablet, as if rotated 180 degrees
+ */
+static const struct dmi_system_id rotated_screen[] = {
+#if defined(CONFIG_DMI) && defined(CONFIG_X86)
+        {
+                .ident = "WinBook TW100",
+                .matches = {
+                        DMI_MATCH(DMI_SYS_VENDOR, "WinBook"),
+                        DMI_MATCH(DMI_PRODUCT_NAME, "TW100")
+                }
+        },
+        {
+                .ident = "WinBook TW700",
+                .matches = {
+                        DMI_MATCH(DMI_SYS_VENDOR, "WinBook"),
+                        DMI_MATCH(DMI_PRODUCT_NAME, "TW700")
+                },
+        },
+#endif
+        {}
 };
 
 /**
@@ -70,78 +117,138 @@ static const unsigned long goodix_irq_fl
  * @len: length of the buffer to write
  */
 static int goodix_i2c_read(struct i2c_client *client,
-				u16 reg, u8 *buf, int len)
+                           u16 reg, u8 *buf, int len)
+{
+        struct i2c_msg msgs[2];
+        u16 wbuf = cpu_to_be16(reg);
+        int ret;
+
+        msgs[0].flags = 0;
+        msgs[0].addr  = client->addr;
+        msgs[0].len   = 2;
+        msgs[0].buf   = (u8 *)&wbuf;
+
+        msgs[1].flags = I2C_M_RD;
+        msgs[1].addr  = client->addr;
+        msgs[1].len   = len;
+        msgs[1].buf   = buf;
+
+        ret = i2c_transfer(client->adapter, msgs, 2);
+        return ret < 0 ? ret : (ret != ARRAY_SIZE(msgs) ? -EIO : 0);
+}
+
+/**
+ * goodix_i2c_write - write data to a register of the i2c slave device.
+ *
+ * @client: i2c device.
+ * @reg: the register to write to.
+ * @buf: raw data buffer to write.
+ * @len: length of the buffer to write
+ */
+static int goodix_i2c_write(struct i2c_client *client, u16 reg, const u8 *buf,
+                            unsigned len)
 {
-	struct i2c_msg msgs[2];
-	u16 wbuf = cpu_to_be16(reg);
-	int ret;
-
-	msgs[0].flags = 0;
-	msgs[0].addr  = client->addr;
-	msgs[0].len   = 2;
-	msgs[0].buf   = (u8 *) &wbuf;
-
-	msgs[1].flags = I2C_M_RD;
-	msgs[1].addr  = client->addr;
-	msgs[1].len   = len;
-	msgs[1].buf   = buf;
+        u8 *addr_buf;
+        struct i2c_msg msg;
+        int ret;
+
+        addr_buf = kmalloc(len + 2, GFP_KERNEL);
+        if (!addr_buf)
+                return -ENOMEM;
+
+        addr_buf[0] = reg >> 8;
+        addr_buf[1] = reg & 0xFF;
+        memcpy(&addr_buf[2], buf, len);
+
+        msg.flags = 0;
+        msg.addr = client->addr;
+        msg.buf = addr_buf;
+        msg.len = len + 2;
+
+        ret = i2c_transfer(client->adapter, &msg, 1);
+        kfree(addr_buf);
+        return ret < 0 ? ret : (ret != 1 ? -EIO : 0);
+}
 
-	ret = i2c_transfer(client->adapter, msgs, 2);
-	return ret < 0 ? ret : (ret != ARRAY_SIZE(msgs) ? -EIO : 0);
+static int goodix_i2c_write_u8(struct i2c_client *client, u16 reg, u8 value)
+{
+        return goodix_i2c_write(client, reg, &value, sizeof(value));
+}
+
+static int goodix_get_cfg_len(u16 id)
+{
+        switch (id) {
+        case 911:
+        case 9271:
+        case 9110:
+        case 927:
+        case 928:
+                return GOODIX_CONFIG_911_LENGTH;
+
+        case 912:
+        case 967:
+                return GOODIX_CONFIG_967_LENGTH;
+
+        default:
+                return GOODIX_CONFIG_MAX_LENGTH;
+        }
 }
 
 static int goodix_ts_read_input_report(struct goodix_ts_data *ts, u8 *data)
 {
-	int touch_num;
-	int error;
+        int touch_num;
+        int error;
 
-	error = goodix_i2c_read(ts->client, GOODIX_READ_COOR_ADDR, data,
-				GOODIX_CONTACT_SIZE + 1);
-	if (error) {
-		dev_err(&ts->client->dev, "I2C transfer error: %d\n", error);
-		return error;
-	}
-
-	touch_num = data[0] & 0x0f;
-	if (touch_num > GOODIX_MAX_CONTACTS)
-		return -EPROTO;
-
-	if (touch_num > 1) {
-		data += 1 + GOODIX_CONTACT_SIZE;
-		error = goodix_i2c_read(ts->client,
-					GOODIX_READ_COOR_ADDR +
-						1 + GOODIX_CONTACT_SIZE,
-					data,
-					GOODIX_CONTACT_SIZE * (touch_num - 1));
-		if (error)
-			return error;
-	}
+        error = goodix_i2c_read(ts->client, GOODIX_READ_COOR_ADDR, data,
+                                GOODIX_CONTACT_SIZE + 1);
+        if (error) {
+                dev_err(&ts->client->dev, "I2C transfer error: %d\n", error);
+                return error;
+        }
+
+        if (!(data[0] & 0x80))
+                return -EAGAIN;
+
+        touch_num = data[0] & 0x0f;
+        if (touch_num > ts->max_touch_num)
+                return -EPROTO;
+
+        if (touch_num > 1) {
+                data += 1 + GOODIX_CONTACT_SIZE;
+                error = goodix_i2c_read(ts->client,
+                                        GOODIX_READ_COOR_ADDR +
+                                                1 + GOODIX_CONTACT_SIZE,
+                                        data,
+                                        GOODIX_CONTACT_SIZE * (touch_num - 1));
+                if (error)
+                        return error;
+        }
 
-	return touch_num;
+        return touch_num;
 }
 
 static void goodix_ts_report_touch(struct goodix_ts_data *ts, u8 *coor_data)
 {
-	int id = coor_data[0] & 0x0F;
-	int input_x = get_unaligned_le16(&coor_data[1]);
-	int input_y = get_unaligned_le16(&coor_data[3]);
-	int input_w = get_unaligned_le16(&coor_data[5]);
-
-	input_mt_slot(ts->input_dev, id);
-	input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, true);
-	if (ts->invert) {
-		input_x = ts->abs_x_max - input_x;
-		input_y = ts->abs_y_max - input_y;
-	}
-	if (ts->rotate) {
-		input_report_abs(ts->input_dev, ABS_MT_POSITION_Y, input_x);
-		input_report_abs(ts->input_dev, ABS_MT_POSITION_X, input_y);
-	} else {
-		input_report_abs(ts->input_dev, ABS_MT_POSITION_X, input_x);
-		input_report_abs(ts->input_dev, ABS_MT_POSITION_Y, input_y);
-	}
-	input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, input_w);
-	input_report_abs(ts->input_dev, ABS_MT_WIDTH_MAJOR, input_w);
+        int id = coor_data[0] & 0x0F;
+        int input_x = get_unaligned_le16(&coor_data[1]);
+        int input_y = get_unaligned_le16(&coor_data[3]);
+        int input_w = get_unaligned_le16(&coor_data[5]);
+
+// printk(KERN_ERR " goodix -> %d %d %d \n", input_x, input_y, input_w);
+        /* Inversions have to happen before axis swapping */
+        if (ts->inverted_x)
+                input_x = ts->abs_x_max - input_x;
+        if (ts->inverted_y)
+                input_y = ts->abs_y_max - input_y;
+        if (ts->swapped_x_y)
+                swap(input_x, input_y);
+
+        input_mt_slot(ts->input_dev, id);
+        input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, true);
+        input_report_abs(ts->input_dev, ABS_MT_POSITION_X, input_x);
+        input_report_abs(ts->input_dev, ABS_MT_POSITION_Y, input_y);
+        input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, input_w);
+        input_report_abs(ts->input_dev, ABS_MT_WIDTH_MAJOR, input_w);
 }
 
 /**
@@ -154,20 +261,20 @@ static void goodix_ts_report_touch(struc
  */
 static void goodix_process_events(struct goodix_ts_data *ts)
 {
-	u8  point_data[1 + GOODIX_CONTACT_SIZE * GOODIX_MAX_CONTACTS];
-	int touch_num;
-	int i;
-
-	touch_num = goodix_ts_read_input_report(ts, point_data);
-	if (touch_num < 0)
-		return;
-
-	for (i = 0; i < touch_num; i++)
-		goodix_ts_report_touch(ts,
-				&point_data[1 + GOODIX_CONTACT_SIZE * i]);
+        u8  point_data[1 + GOODIX_CONTACT_SIZE * GOODIX_MAX_CONTACTS];
+        int touch_num;
+        int i;
+
+        touch_num = goodix_ts_read_input_report(ts, point_data);
+        if (touch_num < 0)
+                return;
+
+        for (i = 0; i < touch_num; i++) 
+                goodix_ts_report_touch(ts,
+                                &point_data[1 + GOODIX_CONTACT_SIZE * i]);
 
-	input_mt_sync_frame(ts->input_dev);
-	input_sync(ts->input_dev);
+        input_mt_sync_frame(ts->input_dev);
+        input_sync(ts->input_dev);
 }
 
 /**
@@ -178,19 +285,198 @@ static void goodix_process_events(struct
  */
 static irqreturn_t goodix_ts_irq_handler(int irq, void *dev_id)
 {
-	static const u8 end_cmd[] = {
-		GOODIX_READ_COOR_ADDR >> 8,
-		GOODIX_READ_COOR_ADDR & 0xff,
-		0
-	};
-	struct goodix_ts_data *ts = dev_id;
+        struct goodix_ts_data *ts = dev_id;
+
+        goodix_process_events(ts);
 
-	goodix_process_events(ts);
+        if (goodix_i2c_write_u8(ts->client, GOODIX_READ_COOR_ADDR, 0) < 0)
+                dev_err(&ts->client->dev, "I2C write end_cmd error\n");
 
-	if (i2c_master_send(ts->client, end_cmd, sizeof(end_cmd)) < 0)
-		dev_err(&ts->client->dev, "I2C write end_cmd error\n");
+        return IRQ_HANDLED;
+}
 
-	return IRQ_HANDLED;
+static void goodix_free_irq(struct goodix_ts_data *ts)
+{
+        devm_free_irq(&ts->client->dev, ts->client->irq, ts);
+}
+
+static int goodix_request_irq(struct goodix_ts_data *ts)
+{
+        return devm_request_threaded_irq(&ts->client->dev, ts->client->irq,
+                                         NULL, goodix_ts_irq_handler,
+                                         ts->irq_flags, ts->client->name, ts);
+}
+
+/**
+ * goodix_check_cfg - Checks if config fw is valid
+ *
+ * @ts: goodix_ts_data pointer
+ * @cfg: firmware config data
+ */
+static int goodix_check_cfg(struct goodix_ts_data *ts,
+                            const struct firmware *cfg)
+{
+        int i, raw_cfg_len;
+        u8 check_sum = 0;
+
+        if (cfg->size > GOODIX_CONFIG_MAX_LENGTH) {
+                dev_err(&ts->client->dev,
+                        "The length of the config fw is not correct");
+                return -EINVAL;
+        }
+
+        raw_cfg_len = cfg->size - 2;
+        for (i = 0; i < raw_cfg_len; i++)
+                check_sum += cfg->data[i];
+        check_sum = (~check_sum) + 1;
+        if (check_sum != cfg->data[raw_cfg_len]) {
+                dev_err(&ts->client->dev,
+                        "The checksum of the config fw is not correct");
+                return -EINVAL;
+        }
+
+        if (cfg->data[raw_cfg_len + 1] != 1) {
+                dev_err(&ts->client->dev,
+                        "Config fw must have Config_Fresh register set");
+                return -EINVAL;
+        }
+
+        return 0;
+}
+
+/**
+ * goodix_send_cfg - Write fw config to device
+ *
+ * @ts: goodix_ts_data pointer
+ * @cfg: config firmware to write to device
+ */
+static int goodix_send_cfg(struct goodix_ts_data *ts,
+                           const struct firmware *cfg)
+{
+        int error;
+
+        error = goodix_check_cfg(ts, cfg);
+        if (error)
+                return error;
+
+        error = goodix_i2c_write(ts->client, GOODIX_REG_CONFIG_DATA, cfg->data,
+                                 cfg->size);
+        if (error) {
+                dev_err(&ts->client->dev, "Failed to write config data: %d",
+                        error);
+                return error;
+        }
+        dev_dbg(&ts->client->dev, "Config sent successfully.");
+
+        /* Let the firmware reconfigure itself, so sleep for 10ms */
+        usleep_range(10000, 11000);
+
+        return 0;
+}
+
+static int goodix_int_sync(struct goodix_ts_data *ts)
+{
+        int error;
+
+        error = gpio_direction_output(ts->gpio_int, 0);
+        if (error)
+                return error;
+
+        msleep(50);                             /* T5: 50ms */
+
+        error = gpio_direction_input(ts->gpio_int);
+        if (error)
+                return error;
+
+        return 0;
+}
+
+/**
+ * goodix_reset - Reset device during power on
+ *
+ * @ts: goodix_ts_data pointer
+ */
+static int goodix_reset(struct goodix_ts_data *ts)
+{
+        int error;
+
+        /* begin select I2C slave addr */
+        error = gpio_direction_output(ts->gpio_rst, 0);
+        if (error)
+                return error;
+
+        msleep(20);                             /* T2: > 10ms */
+
+        /* HIGH: 0x28/0x29, LOW: 0xBA/0xBB */
+        error = gpio_direction_output(ts->gpio_int, ts->client->addr == 0x14);
+        if (error)
+                return error;
+
+        usleep_range(100, 2000);                /* T3: > 100us */
+
+        error = gpio_direction_output(ts->gpio_rst, 1);
+        if (error)
+                return error;
+
+        usleep_range(6000, 10000);              /* T4: > 5ms */
+
+        /* end select I2C slave addr */
+        error = gpio_direction_input(ts->gpio_rst);
+        if (error)
+                return error;
+
+        error = goodix_int_sync(ts);
+        if (error)
+                return error;
+
+        return 0;
+}
+
+/**
+ * goodix_get_gpio_config - Get GPIO config from ACPI/DT
+ *
+ * @ts: goodix_ts_data pointer
+ */
+static int goodix_get_gpio_config(struct goodix_ts_data *ts, struct i2c_client *client)
+{
+        int gpio;
+	struct device *dev;
+
+        if (!ts->client)
+                return -EINVAL;
+
+	dev = &ts->client->dev;
+
+
+	if (!client->dev.of_node)
+                return -EINVAL;
+
+        /* Get the interrupt GPIO pin number */
+        gpio = of_get_named_gpio(client->dev.of_node, GOODIX_GPIO_INT_NAME, 0);
+        if (gpio < 0) {
+                if (gpio != -EPROBE_DEFER)
+                        dev_dbg(dev, "Failed to get %s GPIO: %d\n",
+                                GOODIX_GPIO_INT_NAME, gpio);
+                return gpio;
+        }
+
+        ts->gpio_int = gpio;
+
+        /* Get the reset line GPIO pin number */
+
+        gpio = of_get_named_gpio(client->dev.of_node, GOODIX_GPIO_RST_NAME, 0);
+        if (gpio < 0) {
+                if (gpio != -EPROBE_DEFER)
+                        dev_dbg(dev, "Failed to get %s GPIO: %d\n",
+                                GOODIX_GPIO_RST_NAME, gpio);
+                return gpio;
+        }
+
+        ts->gpio_rst = gpio;
+	devm_gpio_request(&client->dev, ts->gpio_int, NULL);
+	devm_gpio_request(&client->dev, ts->gpio_rst, NULL);
+
+        return 0;
 }
 
 /**
@@ -202,62 +488,76 @@ static irqreturn_t goodix_ts_irq_handler
  */
 static void goodix_read_config(struct goodix_ts_data *ts)
 {
-	u8 config[GOODIX_CONFIG_MAX_LENGTH];
-	int error;
+        u8 config[GOODIX_CONFIG_MAX_LENGTH];
+        int error;
 
-	error = goodix_i2c_read(ts->client, GOODIX_REG_CONFIG_DATA,
-			      config,
-			   GOODIX_CONFIG_MAX_LENGTH);
-	if (error) {
-		dev_warn(&ts->client->dev,
-			 "Error reading config (%d), using defaults\n",
-			 error);
-		ts->abs_x_max = GOODIX_MAX_WIDTH;
-		ts->abs_y_max = GOODIX_MAX_HEIGHT;
-		ts->int_trigger_type = GOODIX_INT_TRIGGER;
-		return;
-	}
-
-	if (ts->rotate) {
-		ts->abs_x_max = get_unaligned_le16(&config[RESOLUTION_LOC + 2]);
-		ts->abs_y_max = get_unaligned_le16(&config[RESOLUTION_LOC]);
-	} else {
-		ts->abs_x_max = get_unaligned_le16(&config[RESOLUTION_LOC]);
-		ts->abs_y_max = get_unaligned_le16(&config[RESOLUTION_LOC + 2]);
-	}
-	ts->int_trigger_type = (config[TRIGGER_LOC]) & 0x03;
-	if (!ts->abs_x_max || !ts->abs_y_max) {
-		dev_err(&ts->client->dev,
-			"Invalid config, using defaults\n");
-		ts->abs_x_max = GOODIX_MAX_WIDTH;
-		ts->abs_y_max = GOODIX_MAX_HEIGHT;
-	}
+        error = goodix_i2c_read(ts->client, GOODIX_REG_CONFIG_DATA,
+                                config, ts->cfg_len);
+        if (error) {
+                dev_warn(&ts->client->dev,
+                         "Error reading config (%d), using defaults\n",
+                         error);
+                ts->abs_x_max = GOODIX_MAX_WIDTH;
+                ts->abs_y_max = GOODIX_MAX_HEIGHT;
+                if (ts->swapped_x_y)
+                        swap(ts->abs_x_max, ts->abs_y_max);
+                ts->int_trigger_type = GOODIX_INT_TRIGGER;
+                ts->max_touch_num = GOODIX_MAX_CONTACTS;
+                return;
+        }
+
+        ts->abs_x_max = get_unaligned_le16(&config[RESOLUTION_LOC]);
+        ts->abs_y_max = get_unaligned_le16(&config[RESOLUTION_LOC + 2]);
+        if (ts->swapped_x_y)
+                swap(ts->abs_x_max, ts->abs_y_max);
+        ts->int_trigger_type = config[TRIGGER_LOC] & 0x03;
+        ts->max_touch_num = config[MAX_CONTACTS_LOC] & 0x0f;
+        if (!ts->abs_x_max || !ts->abs_y_max || !ts->max_touch_num) {
+                dev_err(&ts->client->dev,
+                        "Invalid config, using defaults\n");
+                ts->abs_x_max = GOODIX_MAX_WIDTH;
+                ts->abs_y_max = GOODIX_MAX_HEIGHT;
+                if (ts->swapped_x_y)
+                        swap(ts->abs_x_max, ts->abs_y_max);
+                ts->max_touch_num = GOODIX_MAX_CONTACTS;
+        }
+
+        if (dmi_check_system(rotated_screen)) {
+                ts->inverted_x = true;
+                ts->inverted_y = true;
+                dev_dbg(&ts->client->dev,
+                         "Applying '180 degrees rotated screen' quirk\n");
+        }
 }
 
-
 /**
  * goodix_read_version - Read goodix touchscreen version
  *
- * @client: the i2c client
- * @version: output buffer containing the version on success
+ * @ts: our goodix_ts_data pointer
  */
-static int goodix_read_version(struct i2c_client *client, u16 *version)
+static int goodix_read_version(struct goodix_ts_data *ts)
 {
-	int error;
-	u8 buf[6];
-
-	error = goodix_i2c_read(client, GOODIX_REG_VERSION, buf, sizeof(buf));
-	if (error) {
-		dev_err(&client->dev, "read version failed: %d\n", error);
-		return error;
-	}
+        int error;
+        u8 buf[6];
+        char id_str[5];
+
+        error = goodix_i2c_read(ts->client, GOODIX_REG_ID, buf, sizeof(buf));
+        if (error) {
+                dev_err(&ts->client->dev, "read version failed: %d\n", error);
+                return error;
+        }
+
+        memcpy(id_str, buf, 4);
+        id_str[4] = 0;
+        if (kstrtou16(id_str, 10, &ts->id))
+                ts->id = 0x1001;
 
-	if (version)
-		*version = get_unaligned_le16(&buf[4]);
+        ts->version = get_unaligned_le16(&buf[4]);
 
-	dev_info(&client->dev, "IC VERSION: %6ph\n", buf);
+        dev_info(&ts->client->dev, "ID %d, version: %04x\n", ts->id,
+                 ts->version);
 
-	return 0;
+        return 0;
 }
 
 /**
@@ -267,22 +567,22 @@ static int goodix_read_version(struct i2
  */
 static int goodix_i2c_test(struct i2c_client *client)
 {
-	int retry = 0;
-	int error;
-	u8 test;
-
-	while (retry++ < 2) {
-		error = goodix_i2c_read(client, GOODIX_REG_CONFIG_DATA,
-					&test, 1);
-		if (!error)
-			return 0;
-
-		dev_err(&client->dev, "i2c test failed attempt %d: %d\n",
-			retry, error);
-		msleep(20);
-	}
+        int retry = 0;
+        int error;
+        u8 test;
+
+        while (retry++ < 2) {
+                error = goodix_i2c_read(client, GOODIX_REG_CONFIG_DATA,
+                                        &test, 1);
+                if (!error)
+                        return 0;
+
+                dev_err(&client->dev, "i2c test failed attempt %d: %d\n",
+                        retry, error);
+                msleep(20);
+        }
 
-	return error;
+        return error;
 }
 
 /**
@@ -294,185 +594,307 @@ static int goodix_i2c_test(struct i2c_cl
  */
 static int goodix_request_input_dev(struct goodix_ts_data *ts)
 {
-	int error;
+        int error;
+
+        ts->input_dev = devm_input_allocate_device(&ts->client->dev);
+        if (!ts->input_dev) {
+                dev_err(&ts->client->dev, "Failed to allocate input device.");
+                return -ENOMEM;
+        }
+
+        input_set_abs_params(ts->input_dev, ABS_MT_POSITION_X,
+                             0, ts->abs_x_max, 0, 0);
+        input_set_abs_params(ts->input_dev, ABS_MT_POSITION_Y,
+                             0, ts->abs_y_max, 0, 0);
+        input_set_abs_params(ts->input_dev, ABS_MT_WIDTH_MAJOR, 0, 255, 0, 0);
+        input_set_abs_params(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
+
+        input_mt_init_slots(ts->input_dev, ts->max_touch_num,
+                            INPUT_MT_DIRECT | INPUT_MT_DROP_UNUSED);
+
+        ts->input_dev->name = "Goodix Capacitive TouchScreen";
+        ts->input_dev->phys = "input/ts";
+        ts->input_dev->id.bustype = BUS_I2C;
+        ts->input_dev->id.vendor = 0x0416;
+        ts->input_dev->id.product = ts->id;
+        ts->input_dev->id.version = ts->version;
+
+	__set_bit(EV_SYN, ts->input_dev->evbit);
+	__set_bit(EV_KEY, ts->input_dev->evbit);
+	__set_bit(EV_ABS, ts->input_dev->evbit);
+
+        error = input_register_device(ts->input_dev);
+        if (error) {
+                dev_err(&ts->client->dev,
+                        "Failed to register input device: %d", error);
+                return error;
+        }
+
+        return 0;
+}
+
+/**
+ * goodix_configure_dev - Finish device initialization
+ *
+ * @ts: our goodix_ts_data pointer
+ *
+ * Must be called from probe to finish initialization of the device.
+ * Contains the common initialization code for both devices that
+ * declare gpio pins and devices that do not. It is either called
+ * directly from probe or from request_firmware_wait callback.
+ */
+static int goodix_configure_dev(struct goodix_ts_data *ts)
+{
+        int error;
+	struct i2c_client *client = &ts->client;
 
-	ts->input_dev = devm_input_allocate_device(&ts->client->dev);
-	if (!ts->input_dev) {
-		dev_err(&ts->client->dev, "Failed to allocate input device.");
-		return -ENOMEM;
-	}
-
-	ts->input_dev->evbit[0] = BIT_MASK(EV_SYN) |
-				  BIT_MASK(EV_KEY) |
-				  BIT_MASK(EV_ABS);
-
-	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_X, 0,
-				ts->abs_x_max, 0, 0);
-	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_Y, 0,
-				ts->abs_y_max, 0, 0);
-	input_set_abs_params(ts->input_dev, ABS_MT_WIDTH_MAJOR, 0, 255, 0, 0);
-	input_set_abs_params(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
-
-	input_mt_init_slots(ts->input_dev, GOODIX_MAX_CONTACTS,
-			    INPUT_MT_DIRECT | INPUT_MT_DROP_UNUSED);
-
-	ts->input_dev->name = "Goodix Capacitive TouchScreen";
-	ts->input_dev->phys = "input/ts";
-	ts->input_dev->id.bustype = BUS_I2C;
-	ts->input_dev->id.vendor = 0x0416;
-	ts->input_dev->id.product = 0x1001;
-	ts->input_dev->id.version = 10427;
-
-	error = input_register_device(ts->input_dev);
-	if (error) {
-		dev_err(&ts->client->dev,
-			"Failed to register input device: %d", error);
-		return error;
-	}
+        ts->swapped_x_y = of_property_read_bool(client->dev.of_node,
+                                                    "touchscreen-swapped-x-y");
+        ts->inverted_x = of_property_read_bool(client->dev.of_node,
+                                                   "touchscreen-inverted-x");
+        ts->inverted_y = of_property_read_bool(client->dev.of_node,
+                                                   "touchscreen-inverted-y");
+
+        goodix_read_config(ts);
+
+        error = goodix_request_input_dev(ts);
+        if (error)
+                return error;
+
+        ts->irq_flags = goodix_irq_flags[ts->int_trigger_type] | IRQF_ONESHOT;
+        error = goodix_request_irq(ts);
+        if (error) {
+                dev_err(&ts->client->dev, "request IRQ failed: %d\n", error);
+                return error;
+        }
 
-	return 0;
+        return 0;
+}
+
+/**
+ * goodix_config_cb - Callback to finish device init
+ *
+ * @ts: our goodix_ts_data pointer
+ *
+ * request_firmware_wait callback that finishes
+ * initialization of the device.
+ */
+static void goodix_config_cb(const struct firmware *cfg, void *ctx)
+{
+        struct goodix_ts_data *ts = ctx;
+        int error;
+
+        if (cfg) {
+                /* send device configuration to the firmware */
+                error = goodix_send_cfg(ts, cfg);
+                if (error)
+                        goto err_release_cfg;
+        }
+
+        goodix_configure_dev(ts);
+
+err_release_cfg:
+        release_firmware(cfg);
+        complete_all(&ts->firmware_loading_complete);
 }
 
 static int goodix_ts_probe(struct i2c_client *client,
-			   const struct i2c_device_id *id)
+                           const struct i2c_device_id *id)
 {
-	struct goodix_ts_data *ts;
-	unsigned long irq_flags;
-	int error;
-	u16 version_info;
-#ifdef CONFIG_OF
-	int reset_pin;
-	int int_pin;
-	struct device_node *np = client->dev.of_node;
-#endif
+        struct goodix_ts_data *ts;
+        int error;
 
-	dev_dbg(&client->dev, "I2C Address: 0x%02x\n", client->addr);
+        dev_dbg(&client->dev, "I2C Address: 0x%02x\n", client->addr);
 
-	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
-		dev_err(&client->dev, "I2C check functionality failed.\n");
-		return -ENXIO;
-	}
-
-	ts = devm_kzalloc(&client->dev, sizeof(*ts), GFP_KERNEL);
-	if (!ts)
-		return -ENOMEM;
+        if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+                dev_err(&client->dev, "I2C check functionality failed.\n");
+                return -ENXIO;
+        }
+
+        ts = devm_kzalloc(&client->dev, sizeof(*ts), GFP_KERNEL);
+        if (!ts)
+                return -ENOMEM;
+
+        ts->client = client;
+        i2c_set_clientdata(client, ts);
+        init_completion(&ts->firmware_loading_complete);
+
+        error = goodix_get_gpio_config(ts, client);
+        if (error)
+                return error;
+
+        if (ts->gpio_int && ts->gpio_rst) {
+                /* reset the controller */
+                error = goodix_reset(ts);
+                if (error) {
+                        dev_err(&client->dev, "Controller reset failed.\n");
+                        return error;
+                }
+        }
+
+        error = goodix_i2c_test(client);
+        if (error) {
+                dev_err(&client->dev, "I2C communication failure: %d\n", error);
+                return error;
+        }
+
+        error = goodix_read_version(ts);
+        if (error) {
+                dev_err(&client->dev, "Read version failed.\n");
+                return error;
+        }
+
+        ts->cfg_len = goodix_get_cfg_len(ts->id);
+
+        if (ts->gpio_int && ts->gpio_rst) {
+                /* update device config */
+                ts->cfg_name = devm_kasprintf(&client->dev, GFP_KERNEL,
+                                              "goodix_%d_cfg.bin", ts->id);
+                if (!ts->cfg_name)
+                        return -ENOMEM;
+
+                error = request_firmware_nowait(THIS_MODULE, true, ts->cfg_name,
+                                                &client->dev, GFP_KERNEL, ts,
+                                                goodix_config_cb);
+                if (error) {
+                        dev_err(&client->dev,
+                                "Failed to invoke firmware loader: %d\n",
+                                error);
+                        return error;
+                }
+
+                return 0;
+        } else {
+                error = goodix_configure_dev(ts);
+                if (error)
+                        return error;
+        }
 
-#ifdef CONFIG_OF
-	/*
-	 * The GT9110 requires that INT be driven low by the host for 50ms
-	 * after sampling the state of INT to determine its slave address.
-	 * If reset-gpio and int-gpio are provided in the device-tree, perform
-	 * this init sequence.
-	 */
-	reset_pin = of_get_named_gpio(np, "reset-gpio", 0);
-	int_pin = of_get_named_gpio(np, "int-gpio", 0);
-	if (gpio_is_valid(reset_pin) && gpio_is_valid(int_pin)) {
-		int int_val = (client->addr == 0x14) ?
-			      GPIOF_OUT_INIT_HIGH : GPIOF_OUT_INIT_LOW;
-
-		error = devm_gpio_request_one(&client->dev,
-				reset_pin, GPIOF_OUT_INIT_LOW,
-				"gtxx reset");
-		if (error) {
-			dev_err(&client->dev,
-				"Failed to request gpio%d reset pin: %d\n",
-				reset_pin, error);
-			return error;
-		}
-		error = devm_gpio_request_one(&client->dev,
-				int_pin, int_val, "gtxx int");
-		if (error) {
-			dev_err(&client->dev,
-				"Failed to request gpio%d int pin: %d\n",
-				int_pin, error);
-			return error;
-		}
-
-		msleep(5);
-		gpio_set_value(reset_pin, 1);
-		msleep(5);
-		gpio_set_value(int_pin, 0);
-		msleep(50);
-		gpio_direction_input(int_pin);
-
-		dev_info(&client->dev, "Performed init sequence using "
-			 "gpio%d/gpio%d as RST#/INT\n", reset_pin, int_pin);
-	}
-
-	if (of_property_read_bool(np, "invert"))
-		ts->invert = true;
-	if (of_property_read_bool(np, "rotate"))
-		ts->rotate = true;
-#endif
+        return 0;
+}
+
+static int goodix_ts_remove(struct i2c_client *client)
+{
+        struct goodix_ts_data *ts = i2c_get_clientdata(client);
 
-	ts->client = client;
-	i2c_set_clientdata(client, ts);
+        if (ts->gpio_int && ts->gpio_rst)
+                wait_for_completion(&ts->firmware_loading_complete);
 
-	error = goodix_i2c_test(client);
-	if (error) {
-		dev_err(&client->dev, "I2C communication failure: %d\n", error);
-		return error;
-	}
-
-	error = goodix_read_version(client, &version_info);
-	if (error) {
-		dev_err(&client->dev, "Read version failed.\n");
-		return error;
-	}
-
-	goodix_read_config(ts);
-
-	error = goodix_request_input_dev(ts);
-	if (error)
-		return error;
-
-	irq_flags = goodix_irq_flags[ts->int_trigger_type] | IRQF_ONESHOT;
-	error = devm_request_threaded_irq(&ts->client->dev, client->irq,
-					  NULL, goodix_ts_irq_handler,
-					  irq_flags, client->name, ts);
-	if (error) {
-		dev_err(&client->dev, "request IRQ failed: %d\n", error);
-		return error;
-	}
+        return 0;
+}
 
-	return 0;
+static int __maybe_unused goodix_suspend(struct device *dev)
+{
+        struct i2c_client *client = to_i2c_client(dev);
+        struct goodix_ts_data *ts = i2c_get_clientdata(client);
+        int error;
+
+        /* We need gpio pins to suspend/resume */
+        if (!ts->gpio_int || !ts->gpio_rst)
+                return 0;
+
+        wait_for_completion(&ts->firmware_loading_complete);
+
+        /* Free IRQ as IRQ pin is used as output in the suspend sequence */
+        goodix_free_irq(ts);
+
+        /* Output LOW on the INT pin for 5 ms */
+        error = gpio_direction_output(ts->gpio_int, 0);
+        if (error) {
+                goodix_request_irq(ts);
+                return error;
+        }
+
+        usleep_range(5000, 6000);
+
+        error = goodix_i2c_write_u8(ts->client, GOODIX_REG_COMMAND,
+                                    GOODIX_CMD_SCREEN_OFF);
+        if (error) {
+                dev_err(&ts->client->dev, "Screen off command failed\n");
+                gpio_direction_input(ts->gpio_int);
+                goodix_request_irq(ts);
+                return -EAGAIN;
+        }
+
+        /*
+         * The datasheet specifies that the interval between sending screen-off
+         * command and wake-up should be longer than 58 ms. To avoid waking up
+         * sooner, delay 58ms here.
+         */
+        msleep(58);
+        return 0;
 }
 
+static int __maybe_unused goodix_resume(struct device *dev)
+{
+        struct i2c_client *client = to_i2c_client(dev);
+        struct goodix_ts_data *ts = i2c_get_clientdata(client);
+        int error;
+
+        if (!ts->gpio_int || !ts->gpio_rst)
+                return 0;
+
+        /*
+         * Exit sleep mode by outputting HIGH level to INT pin
+         * for 2ms~5ms.
+         */
+        error = gpio_direction_output(ts->gpio_int, 1);
+        if (error)
+                return error;
+
+        usleep_range(2000, 5000);
+
+        error = goodix_int_sync(ts);
+        if (error)
+                return error;
+
+        error = goodix_request_irq(ts);
+        if (error)
+                return error;
+
+        return 0;
+}
+
+static SIMPLE_DEV_PM_OPS(goodix_pm_ops, goodix_suspend, goodix_resume);
+
 static const struct i2c_device_id goodix_ts_id[] = {
-	{ "GDIX1001:00", 0 },
-	{ }
+        { "GDIX1001:00", 0 },
+        { }
 };
 MODULE_DEVICE_TABLE(i2c, goodix_ts_id);
 
 #ifdef CONFIG_ACPI
 static const struct acpi_device_id goodix_acpi_match[] = {
-	{ "GDIX1001", 0 },
-	{ }
+        { "GDIX1001", 0 },
+        { }
 };
 MODULE_DEVICE_TABLE(acpi, goodix_acpi_match);
 #endif
 
 #ifdef CONFIG_OF
 static const struct of_device_id goodix_of_match[] = {
-	{ .compatible = "gdx,gt9xx", },
-	{ /* sentinel */ }
+        { .compatible = "goodix,gt911" },
+        { .compatible = "goodix,gt9110" },
+        { .compatible = "goodix,gt912" },
+        { .compatible = "goodix,gt927" },
+        { .compatible = "goodix,gt9271" },
+        { .compatible = "goodix,gt928" },
+        { .compatible = "goodix,gt967" },
+        { }
 };
 MODULE_DEVICE_TABLE(of, goodix_of_match);
 #endif
 
 static struct i2c_driver goodix_ts_driver = {
-	.probe = goodix_ts_probe,
-	.id_table = goodix_ts_id,
-	.driver = {
-		.name = "Goodix-TS",
-		.owner = THIS_MODULE,
-#ifdef CONFIG_ACPI
-		.acpi_match_table = goodix_acpi_match,
-#endif
-#ifdef CONFIG_OF
-		.of_match_table = of_match_ptr(goodix_of_match),
-#endif
-	},
+        .probe = goodix_ts_probe,
+        .remove = goodix_ts_remove,
+        .id_table = goodix_ts_id,
+        .driver = {
+                .name = "Goodix-TS",
+                .acpi_match_table = ACPI_PTR(goodix_acpi_match),
+                .of_match_table = of_match_ptr(goodix_of_match),
+                .pm = &goodix_pm_ops,
+        },
 };
 module_i2c_driver(goodix_ts_driver);
 
Index: git/include/linux/device.h
===================================================================
--- git.orig/include/linux/device.h
+++ git/include/linux/device.h
@@ -609,6 +609,10 @@ extern int devres_release_group(struct d
 
 /* managed devm_k.alloc/kfree for device drivers */
 extern void *devm_kmalloc(struct device *dev, size_t size, gfp_t gfp);
+extern char *devm_kvasprintf(struct device *dev, gfp_t gfp, const char *fmt,
+                             va_list ap);
+extern char *devm_kasprintf(struct device *dev, gfp_t gfp,
+                            const char *fmt, ...);
 static inline void *devm_kzalloc(struct device *dev, size_t size, gfp_t gfp)
 {
 	return devm_kmalloc(dev, size, gfp | __GFP_ZERO);
